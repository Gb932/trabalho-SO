#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#define MAX_THREADS 8
#define BUFFER_SIZE 1024

typedef struct
{
    int *values;
    int size;
    struct timespec start_time;
    struct timespec end_time;
} thread_data_t;

// Declaração da função de comparação
int compare(const void *a, const void *b);

void *thread_func(void *arg)
{
    thread_data_t *data = (thread_data_t *)arg;
    int *values = data->values;
    int size = data->size;

    // Registra o tempo de início da thread
    clock_gettime(CLOCK_MONOTONIC, &data->start_time);

    // Ordena os valores inteiros
    qsort(values, size, sizeof(int), compare);

    // Registra o tempo de fim da thread
    clock_gettime(CLOCK_MONOTONIC, &data->end_time);

    return NULL;
}

int compare(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

int main(int argc, char *argv[])
{
    if (argc < 5) // Mínimo de argumentos
    {
        fprintf(stderr, "Use: %s <num_threads> <input_file1> <input_file2> ... -o <output_file>\n", argv[0]);
        return 1;
    }

    int num_threads = atoi(argv[1]);
    // Verifica se o número de threads é válido (1, 2, 4 ou 8)
    if (num_threads != 1 && num_threads != 2 && num_threads != 4 && num_threads != 8)
    {
        fprintf(stderr, "Número de threads inválido. Escolha 1, 2, 4 ou 8 threads.\n");
        return 1;
    }

    char *output_file = NULL;
    int num_files = 0;
    char **input_files = NULL;

    // Processa os argumentos para identificar arquivos de entrada e o arquivo de saída
    for (int i = 2; i < argc; i++)
    {
        if (strcmp(argv[i], "-o") == 0 && i + 1 < argc)
        {
            output_file = argv[i + 1];
            break;
        }
        num_files++;
    }

    if (!output_file || num_files == 0)
    {
        fprintf(stderr, "Erro: Formato de entrada inválido. Use: %s <num_threads> <input_file1> <input_file2> ... -o <output_file>\n", argv[0]);
        return 1;
    }

    input_files = argv + 2;

    // Abre os arquivos de entrada e lê os números inteiros
    int total_values = 0;
    int **values = malloc(num_files * sizeof(int *));
    int file_sizes[num_files];
    if (values == NULL)
    {
        perror("malloc");
        return 1;
    }

    for (int i = 0; i < num_files; i++)
    {
        FILE *file = fopen(input_files[i], "r");
        if (!file)
        {
            perror("fopen");
            return 1;
        }

        int value;
        int count = 0;
        int capacity = BUFFER_SIZE;
        values[i] = malloc(capacity * sizeof(int));
        if (values[i] == NULL)
        {
            perror("malloc");
            fclose(file);
            return 1;
        }

        // Lê cada número no formato de char e converte para int
        while (fscanf(file, "%d", &value) == 1)
        {
            if (count >= capacity)
            {
                capacity *= 2;
                values[i] = realloc(values[i], capacity * sizeof(int));
                if (values[i] == NULL)
                {
                    perror("realloc");
                    fclose(file);
                    return 1;
                }
            }
            values[i][count++] = value;
        }
        fclose(file);

        file_sizes[i] = count;
        total_values += count;
    }

    // Cria um buffer para armazenar todos os valores inteiros
    int *buffer = malloc(total_values * sizeof(int));
    if (buffer == NULL)
    {
        perror("malloc");
        return 1;
    }

    int buffer_index = 0;
    for (int i = 0; i < num_files; i++)
    {
        memcpy(buffer + buffer_index, values[i], file_sizes[i] * sizeof(int));
        buffer_index += file_sizes[i];
        free(values[i]);
    }
    free(values);

    // Divide o buffer em partes para cada thread
    int chunk_size = (total_values + num_threads - 1) / num_threads; // Arredonda para cima
    pthread_t threads[num_threads];
    thread_data_t thread_data[num_threads];

    // Inicializa o tempo total de execução antes de iniciar as threads
    struct timespec total_start_time, total_end_time;
    clock_gettime(CLOCK_MONOTONIC, &total_start_time);

    for (int i = 0; i < num_threads; i++)
    {
        thread_data[i].values = buffer + i * chunk_size;
        thread_data[i].size = (i == num_threads - 1) ? (total_values - i * chunk_size) : chunk_size;
        pthread_create(&threads[i], NULL, thread_func, &thread_data[i]);
    }

    // Aguarda que todas as threads terminem
    for (int i = 0; i < num_threads; i++)
    {
        pthread_join(threads[i], NULL);
    }
    clock_gettime(CLOCK_MONOTONIC, &total_end_time);

    // Ordena o buffer completo
    qsort(buffer, total_values, sizeof(int), compare);

    // Imprime os tempos de execução de cada thread
    for (int i = 0; i < num_threads; i++)
    {
        struct timespec diff;
        diff.tv_sec = thread_data[i].end_time.tv_sec - thread_data[i].start_time.tv_sec;
        diff.tv_nsec = thread_data[i].end_time.tv_nsec - thread_data[i].start_time.tv_nsec;
        if (diff.tv_nsec < 0)
        {
            diff.tv_sec--;
            diff.tv_nsec += 1000000000;
        }
        printf("Tempo de execução do Thread %d: %ld.%09ld segundos.\n", i, diff.tv_sec, diff.tv_nsec);
    }

    // Imprime o tempo total de execução
    struct timespec total_diff;
    total_diff.tv_sec = total_end_time.tv_sec - total_start_time.tv_sec;
    total_diff.tv_nsec = total_end_time.tv_nsec - total_start_time.tv_nsec;
    if (total_diff.tv_nsec < 0)
    {
        total_diff.tv_sec--;
        total_diff.tv_nsec += 1000000000;
    }
    printf("Tempo total de execução: %ld.%09ld segundos.\n", total_diff.tv_sec, total_diff.tv_nsec);

    // Escreve o buffer ordenado no arquivo de saída
    FILE *fd_out = fopen(output_file, "w");
    if (!fd_out)
    {
        perror("fopen");
        free(buffer);
        return 1;
    }

    for (int i = 0; i < total_values; i++)
    {
        fprintf(fd_out, "%d\n", buffer[i]);
    }
    fclose(fd_out);

    // Libera a memória
    free(buffer);

    return 0;
}
