#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#define MAX_THREADS 8
#define BUFFER_SIZE 1024

typedef struct
{
    int *values;
    int size;
    struct timespec start_time;
    struct timespec end_time;
} thread_data_t;

// Declaração da função de comparação
int compare(const void *a, const void *b);

// Função para processar os argumentos de entrada
int process_arguments(int argc, char *argv[], int *num_threads, char ***input_files, int *num_files, char **output_file);

// Função para ler valores dos arquivos de entrada
int read_input_files(char **input_files, int num_files, int ***values, int *total_values, int *file_sizes);

// Função de ordenação para cada thread
void *thread_func(void *arg);

// Função para dividir o buffer entre as threads
void divide_buffer(int *buffer, int total_values, int num_threads, thread_data_t *thread_data);

// Função para imprimir tempos de execução das threads e do programa
void print_execution_times(struct timespec total_start_time, struct timespec total_end_time, thread_data_t *thread_data, int num_threads);

// Função para escrever o buffer ordenado no arquivo de saída
int write_output_file(const char *output_file, int *buffer, int total_values);

int main(int argc, char *argv[])
{
    int num_threads;
    char *output_file;
    int num_files;
    char **input_files;

    // Processa os argumentos de entrada
    if (!process_arguments(argc, argv, &num_threads, &input_files, &num_files, &output_file))
    {
        return 1;
    }

    // Lê os valores dos arquivos de entrada
    int **values;
    int total_values;
    int file_sizes[num_files];
    if (read_input_files(input_files, num_files, &values, &total_values, file_sizes) != 0)
    {
        return 1;
    }

    // Cria um buffer para armazenar todos os valores inteiros
    int *buffer = malloc(total_values * sizeof(int));
    if (buffer == NULL)
    {
        perror("malloc");
        return 1;
    }

    int buffer_index = 0;
    for (int i = 0; i < num_files; i++)
    {
        memcpy(buffer + buffer_index, values[i], file_sizes[i] * sizeof(int));
        buffer_index += file_sizes[i];
        free(values[i]);
    }
    free(values);

    pthread_t threads[num_threads];
    thread_data_t thread_data[num_threads];

    // Inicializa o tempo total de execução antes de iniciar as threads
    struct timespec total_start_time, total_end_time;
    clock_gettime(CLOCK_MONOTONIC, &total_start_time);

    // Divide o buffer e cria as threads
    divide_buffer(buffer, total_values, num_threads, thread_data);
    for (int i = 0; i < num_threads; i++)
    {
        pthread_create(&threads[i], NULL, thread_func, &thread_data[i]);
    }

    // Aguarda que todas as threads terminem
    for (int i = 0; i < num_threads; i++)
    {
        pthread_join(threads[i], NULL);
    }
    clock_gettime(CLOCK_MONOTONIC, &total_end_time);

    // Ordena o buffer completo
    qsort(buffer, total_values, sizeof(int), compare);

    // Imprime os tempos de execução de cada thread
    print_execution_times(total_start_time, total_end_time, thread_data, num_threads);

    // Escreve o buffer ordenado no arquivo de saída
    if (write_output_file(output_file, buffer, total_values) != 0)
    {
        free(buffer);
        return 1;
    }

    // Libera a memória
    free(buffer);

    return 0;
}

int compare(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

void *thread_func(void *arg)
{
    thread_data_t *data = (thread_data_t *)arg;
    int *values = data->values;
    int size = data->size;

    clock_gettime(CLOCK_MONOTONIC, &data->start_time);
    qsort(values, size, sizeof(int), compare);
    clock_gettime(CLOCK_MONOTONIC, &data->end_time);

    return NULL;
}

int process_arguments(int argc, char *argv[], int *num_threads, char ***input_files, int *num_files, char **output_file)
{
    if (argc < 5)
    {
        fprintf(stderr, "Use: %s <num_threads> <input_file1> <input_file2> ... -o <output_file>\n", argv[0]);
        return 0;
    }

    *num_threads = atoi(argv[1]);
    if (*num_threads != 1 && *num_threads != 2 && *num_threads != 4 && *num_threads != 8)
    {
        fprintf(stderr, "Número de threads inválido. Escolha 1, 2, 4 ou 8 threads.\n");
        return 0;
    }

    *output_file = NULL;
    *num_files = 0;

    for (int i = 2; i < argc; i++)
    {
        if (strcmp(argv[i], "-o") == 0 && i + 1 < argc)
        {
            *output_file = argv[i + 1];
            break;
        }
        (*num_files)++;
    }

    if (!*output_file || *num_files == 0)
    {
        fprintf(stderr, "Erro: Formato de entrada inválido. Use: %s <num_threads> <input_file1> <input_file2> ... -o <output_file>\n", argv[0]);
        return 0;
    }

    *input_files = argv + 2;
    return 1;
}

int read_input_files(char **input_files, int num_files, int ***values, int *total_values, int *file_sizes)
{
    *values = malloc(num_files * sizeof(int *));
    if (*values == NULL)
    {
        perror("malloc");
        return 1;
    }

    *total_values = 0;
    for (int i = 0; i < num_files; i++)
    {
        FILE *file = fopen(input_files[i], "r");
        if (!file)
        {
            perror("fopen");
            return 1;
        }

        int value, count = 0, capacity = BUFFER_SIZE;
        (*values)[i] = malloc(capacity * sizeof(int));
        if ((*values)[i] == NULL)
        {
            perror("malloc");
            fclose(file);
            return 1;
        }

        while (fscanf(file, "%d", &value) == 1)
        {
            if (count >= capacity)
            {
                capacity *= 2;
                (*values)[i] = realloc((*values)[i], capacity * sizeof(int));
                if ((*values)[i] == NULL)
                {
                    perror("realloc");
                    fclose(file);
                    return 1;
                }
            }
            (*values)[i][count++] = value;
        }
        fclose(file);

        file_sizes[i] = count;
        *total_values += count;
    }

    return 0;
}

void divide_buffer(int *buffer, int total_values, int num_threads, thread_data_t *thread_data)
{
    int chunk_size = (total_values + num_threads - 1) / num_threads;

    for (int i = 0; i < num_threads; i++)
    {
        thread_data[i].values = buffer + i * chunk_size;
        thread_data[i].size = (i == num_threads - 1) ? (total_values - i * chunk_size) : chunk_size;
    }
}

void print_execution_times(struct timespec total_start_time, struct timespec total_end_time, thread_data_t *thread_data, int num_threads)
{
    struct timespec total_diff;
    total_diff.tv_sec = total_end_time.tv_sec - total_start_time.tv_sec;
    total_diff.tv_nsec = total_end_time.tv_nsec - total_start_time.tv_nsec;
    if (total_diff.tv_nsec < 0)
    {
        total_diff.tv_sec--;
        total_diff.tv_nsec += 1000000000;
    }

    for (int i = 0; i < num_threads; i++)
    {
        struct timespec diff;
        diff.tv_sec = thread_data[i].end_time.tv_sec - thread_data[i].start_time.tv_sec;
        diff.tv_nsec = thread_data[i].end_time.tv_nsec - thread_data[i].start_time.tv_nsec;
        if (diff.tv_nsec < 0)
        {
            diff.tv_sec--;
            diff.tv_nsec += 1000000000;
        }
        printf("Tempo de execução do Thread %d: %ld.%09ld segundos.\n", i, diff.tv_sec, diff.tv_nsec);
    }

    printf("Tempo total de execução: %ld.%09ld segundos.\n", total_diff.tv_sec, total_diff.tv_nsec);
}

int write_output_file(const char *output_file, int *buffer, int total_values)
{
    FILE *fd_out = fopen(output_file, "w");
    if (!fd_out)
    {
        perror("fopen");
        return 1;
    }

    for (int i = 0; i < total_values; i++)
    {
        fprintf(fd_out, "%d\n", buffer[i]);
    }
    fclose(fd_out);

    return 0;
}
