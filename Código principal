#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#define MAX_THREADS 8
#define BUFFER_SIZE 1024

typedef struct
{
    int *values;
    int size;
    struct timespec start_time;
    struct timespec end_time;
} thread_data_t;

// Declaração da função compare
int compare(const void *a, const void *b);

void *thread_func(void *arg)
{
    thread_data_t *data = (thread_data_t *)arg;
    int *values = data->values;
    int size = data->size;

    // Registra o tempo de início da thread
    clock_gettime(CLOCK_MONOTONIC, &data->start_time);

    // Ordena os valores inteiros
    qsort(values, size, sizeof(int), compare);

    // Registra o tempo de fim da thread
    clock_gettime(CLOCK_MONOTONIC, &data->end_time);

    return NULL;
}

int compare(const void *a, const void *b)
{
    return (*(int *)a - *(int *)b);
}

int main(int argc, char *argv[])
{
//mergesort 4 arq1.dat arq2.dat arq3.dat –o saida.dat
    if (argc < 3)
    {
        fprintf(stderr, "Usage: %s <num_threads> <output_file> <input_file1> <input_file2> ...\n", argv[0]);
        return 1;
    }

    //int num_threads = atoi(argv[1]);
    int num_threads = atoi(argv[0]);
    if (num_threads < 1 || num_threads > MAX_THREADS)
    {
        fprintf(stderr, "Número de threads inválido. O número deve ser entre 1 e %d.\n", MAX_THREADS);
        return 1;
    }

    //char *output_file = argv[2];
    char *output_file = argv[arqv.length()-1];
    int num_files = argc - 3;
    char **input_files = argv + 3;

    // Abre os arquivos de entrada
    int *fds = malloc(num_files * sizeof(int));
    int total_values = 0;
    int *values[num_files];
    for (int i = 0; i < num_files; i++)
    {
        fds[i] = open(input_files[i], O_RDONLY);
        if (fds[i] == -1)
        {
            perror("open");
            return 1;
        }
        struct stat st;
        fstat(fds[i], &st);
        int size = st.st_size / sizeof(int);
        values[i] = malloc(size * sizeof(int));
        read(fds[i], values[i], size * sizeof(int));
        total_values += size;
    }

    // Cria um buffer para armazenar todos os valores inteiros
    int *buffer = malloc(total_values * sizeof(int));
    int buffer_index = 0;
    for (int i = 0; i < num_files; i++)
    {
        struct stat st;
        fstat(fds[i], &st);
        int size = st.st_size / sizeof(int);
        memcpy(buffer + buffer_index, values[i], size * sizeof(int));
        buffer_index += size;
    }

    // Fecha os arquivos de entrada
    for (int i = 0; i < num_files; i++)
    {
        close(fds[i]);
        free(values[i]);
    }
    free(fds);

    // Divide o buffer em partes para cada thread
    int chunk_size = (total_values + num_threads - 1) / num_threads; // Arredonda para cima
    pthread_t threads[num_threads];
    thread_data_t thread_data[num_threads];

    // Inicializa o tempo total de execução antes de iniciar as threads
    struct timespec total_start_time, total_end_time;
    clock_gettime(CLOCK_MONOTONIC, &total_start_time);

    for (int i = 0; i < num_threads; i++)
    {
        thread_data[i].values = buffer + i * chunk_size;
        thread_data[i].size = (i == num_threads - 1) ? (total_values - i * chunk_size) : chunk_size;
        pthread_create(&threads[i], NULL, thread_func, &thread_data[i]);
    }

    // Aguarda que todas as threads terminem
    for (int i = 0; i < num_threads; i++)
    {
        pthread_join(threads[i], NULL);
    }
    clock_gettime(CLOCK_MONOTONIC, &total_end_time);

    // Imprime os tempos de execução de cada thread
    for (int i = 0; i < num_threads; i++)
    {
        struct timespec diff;
        diff.tv_sec = thread_data[i].end_time.tv_sec - thread_data[i].start_time.tv_sec;
        diff.tv_nsec = thread_data[i].end_time.tv_nsec - thread_data[i].start_time.tv_nsec;
        if (diff.tv_nsec < 0)
        {
            diff.tv_sec--;
            diff.tv_nsec += 1000000000;
        }
        printf("Tempo de execução do Thread %d: %ld.%09ld segundos.\n", i, diff.tv_sec, diff.tv_nsec);
    }

    // Imprime o tempo total de execução
    struct timespec total_diff;
    total_diff.tv_sec = total_end_time.tv_sec - total_start_time.tv_sec;
    total_diff.tv_nsec = total_end_time.tv_nsec - total_start_time.tv_nsec;
    if (total_diff.tv_nsec < 0)
    {
        total_diff.tv_sec--;
        total_diff.tv_nsec += 1000000000;
    }
    printf("Tempo total de execução: %ld.%09ld segundos.\n", total_diff.tv_sec, total_diff.tv_nsec);

    // Escreve o buffer ordenado no arquivo de saída
    int fd_out = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd_out == -1)
    {
        perror("open");
        return 1;
    }
    write(fd_out, buffer, total_values * sizeof(int));
    close(fd_out);

    // Libera a memória
    free(buffer);

    return 0;
}
